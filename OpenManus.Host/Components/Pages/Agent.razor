@page "/"
@page "/agent"
@page "/agent/{SessionId}"
@using OpenManus.Host.Models
@using OpenManus.Host.Services
@inject AgentService AgentService
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@rendermode InteractiveServer

<PageTitle>OpenManus Agent</PageTitle>
<div class="agent-content" style="display:flex;flex-direction:row;height:calc(100vh - 88px);position:relative;">
	<!-- 主内容区域 -->
	<div class="main-chat-area" style="flex:1;display:flex;flex-direction:column;position:relative;transition:margin-right 0.3s ease;@(isFilePreviewModalVisible ? "margin-right:400px;" : "")">
		<!-- 消息显示区域 -->
		<div class="messages-container" style="flex:1;overflow-y:auto;padding: 20px 20px 150px 20px;height: calc(100% - 220px);">
			@if (agentMemory == null || !agentMemory.Messages.Any())
			{
				<div class="welcome-message">
					<div class="welcome-content">
						<i class="fas fa-robot fa-3x text-primary mb-3"></i>
						<h5>欢迎使用 OpenManus AI Agent</h5>
						<p>我是一个多功能AI助手，可以帮助您：</p>
						<ul class="feature-list">
							<li><i class="fas fa-file"></i> 文件操作和管理</li>
							<li><i class="fab fa-python"></i> Python代码执行</li>
							<li><i class="fas fa-search"></i> 信息搜索</li>
							<li><i class="fas fa-tasks"></i> 复杂任务规划和执行</li>
						</ul>
						<p>请输入您的任务或问题，我将为您提供帮助。</p>
					</div>
				</div>
			}
			else
			{
				@* 
					AI代理主页面组件 - 应用程序的核心交互界面
					提供与AI代理的对话功能、文件预览、任务执行状态显示
					支持多会话管理、实时消息流、工具调用结果展示和文件操作
				*@
				@* 内容流式输出展示区，实时滚动定位到底部 *@
				<div class="agent-messages" id="agentMessages">
					@foreach (var message in agentMemory.Messages.Where(m => m.Role != "system"))
					{
						<div class="message @GetMessageClass(message.Role)">
							<div class="message-avatar">
								@if (message.Role == "user")
								{
									<i class="fas fa-user"></i>
								}
								else if (message.Role == "assistant")
								{
									<i class="fas fa-robot"></i>
								}
								else if (message.Role == "tool")
								{
									<i class="fas fa-cog"></i>
								}
							</div>
							<div class="message-content">
								<div class="message-text">
									@if (message.Role == "tool")
									{
										<div class="tool-result">
											<strong>工具执行结果:</strong>
											<pre>@message.Content</pre>
										</div>
									}
									else
									{
										@((MarkupString)FormatMessageContent(message.Content))
										@if (message.Role == "assistant" && ContainsFileReference(message.Content))
										{
											<div class="file-actions">
												@foreach (var fileRef in ExtractFileReferences(message.Content))
												{
													<button class="btn btn-sm btn-outline-primary file-preview-btn"
															@onclick="() => ShowFilePreview(fileRef.Name, fileRef.Path)">
														<i class="fas fa-eye"></i> 预览 @fileRef.Name
													</button>
												}
											</div>
										}
									}
								</div>
								<div class="message-time">@message.Timestamp.ToString("HH:mm:ss")</div>
							</div>
						</div>
					}
				</div>
			}

			<!-- 执行结果显示 -->
			@if (currentExecution != null)
			{
				<div class="execution-status" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 20px; margin: 15px 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 1px solid rgba(255,255,255,0.1);">
					<div class="execution-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
						<h6 style="color: white; margin: 0; font-weight: 600;">
							@if (currentExecution.IsCompleted)
							{
								<i class="fas fa-check-circle" style="color: #4CAF50;"></i>
							}
							else
							{
								<i class="fas fa-cog fa-spin" style="color: #FFC107;"></i>
							}
							任务执行状态
						</h6>
						@if (currentExecution.IsCompleted)
						{
							<span class="badge" style="background: #4CAF50; color: white; padding: 5px 12px; border-radius: 20px; font-size: 12px;">已完成</span>
						}
						else
						{
							<span class="badge" style="background: #FFC107; color: #333; padding: 5px 12px; border-radius: 20px; font-size: 12px; animation: pulse 2s infinite;">进行中</span>
						}
					</div>
					<div class="execution-steps" style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 15px; backdrop-filter: blur(10px);">
						@for (int i = 0; i < currentExecution.Steps.Count; i++)
						{
							var step = currentExecution.Steps[i];
							var isLatest = i == currentExecution.Steps.Count - 1;
							<div class="execution-step" style="display: flex; align-items: center; margin: 8px 0; padding: 8px 12px; border-radius: 6px; background: @(isLatest && !currentExecution.IsCompleted ? "rgba(255,193,7,0.2)" : "rgba(255,255,255,0.05)"); transition: all 0.3s ease; @(isLatest && !currentExecution.IsCompleted ? "animation: stepHighlight 2s infinite;" : "")">
								<i class="fas @(currentExecution.IsCompleted || i < currentExecution.Steps.Count - 1 ? "fa-check-circle" : "fa-clock")" style="color: @(currentExecution.IsCompleted || i < currentExecution.Steps.Count - 1 ? "#4CAF50" : "#FFC107"); margin-right: 10px; font-size: 14px;"></i>
								<span style="color: white; font-size: 14px; flex: 1;">@step</span>
								@if (isLatest && !currentExecution.IsCompleted)
								{
									<div class="spinner-border spinner-border-sm" style="color: #FFC107; width: 16px; height: 16px;" role="status"></div>
								}
							</div>
						}
					</div>
					@if (!string.IsNullOrEmpty(currentExecution.FinalResult))
					{
						<div class="execution-result" style="background: rgba(76,175,80,0.1); border: 1px solid rgba(76,175,80,0.3); border-radius: 8px; padding: 15px; margin-top: 15px;">
							<strong style="color: #4CAF50; display: flex; align-items: center; margin-bottom: 8px;">
								<i class="fas fa-check-circle" style="margin-right: 8px;"></i>
								最终结果:
							</strong>
							<div class="result-content" style="color: white; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; font-family: 'Consolas', monospace;">@currentExecution.FinalResult</div>
						</div>
					}
					@if (!string.IsNullOrEmpty(currentExecution.Error))
					{
						<div class="execution-error" style="background: rgba(244,67,54,0.1); border: 1px solid rgba(244,67,54,0.3); border-radius: 8px; padding: 15px; margin-top: 15px;">
							<strong style="color: #F44336; display: flex; align-items: center; margin-bottom: 8px;">
								<i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
								错误:
							</strong>
							<div class="error-content" style="color: #FFCDD2; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; font-family: 'Consolas', monospace;">@currentExecution.Error</div>
						</div>
					}
				</div>
			}
		</div>

		@* 
			AI代理主页面组件 - 应用程序的核心交互界面
			提供与AI代理的对话功能、文件预览、任务执行状态显示
			支持多会话管理、实时消息流、工具调用结果展示和文件操作
		*@
		@* 固定在Agent页面底部的输入框区域 *@
		<AgentInputArea CurrentMessage="@currentMessage"
						CurrentMessageChanged="@(value => { currentMessage = value; StateHasChanged(); })"
						IsProcessing="@isProcessing"
						IsFilePreviewVisible="@isFilePreviewModalVisible"
						SelectedFiles="@selectedFiles"
						OnExecuteTask="@(() => ExecuteTask())"
						OnOpenFilePreview="@(() => OpenFilePreviewModal())"
						OnFileSelected="@((e) => OnFileSelected(e))"
						OnKeyPress="@(async (e) => await HandleKeyPress(e))" />
	</div>

	<!-- 右侧文件预览面板 -->
	@if (isFilePreviewModalVisible)
	{
		<div class="file-preview-sidebar" style="position:fixed;top:0;right:0;width:400px;height:100vh;background:#1e1e1e;border-left:1px solid #333;z-index:1001;transform:translateX(@(isFilePreviewModalVisible ? "0" : "100%"));transition:transform 0.3s ease;">
			<div class="sidebar-header" style="padding:15px;border-bottom:1px solid #333;display:flex;justify-content:space-between;align-items:center;">
				<h5 class="mb-0 text-light">
					<i class="fas fa-file-alt"></i> 文件预览
				</h5>
				<button type="button" class="btn btn-outline-light btn-sm" @onclick="CloseFilePreviewModal">
					<i class="fas fa-times"></i>
				</button>
			</div>
			<div class="sidebar-body" style="height:calc(100vh - 70px);overflow:hidden;">
				<div class="file-preview-content" style="height:100%;display:flex;flex-direction:column;">
					@if (currentPreviewFile != null)
					{
						<div class="file-info" style="padding:15px;border-bottom:1px solid #333;flex-shrink:0;">
							<h6 class="text-light"><i class="fas fa-file-alt"></i> @currentPreviewFile.Name</h6>
							<p class="file-path text-muted mb-0 small">@currentPreviewFile.Path</p>
						</div>
						<div class="file-content" style="flex:1;overflow:auto;padding:15px;">
							@if (isLoadingFile)
							{
								<div class="loading-spinner text-center">
									<i class="fas fa-spinner fa-spin fa-2x text-light"></i>
									<p class="mt-2 text-light">正在加载文件内容...</p>
								</div>
							}
							else
							{
								<pre style="background:#2d2d2d;color:#f8f8f2;padding:15px;border-radius:5px;margin:0;white-space:pre-wrap;word-wrap:break-word;font-size:12px;line-height:1.4;"><code>@currentPreviewFile.Content</code></pre>
							}
						</div>
					}
					else
					{
						<div class="no-file-selected text-center" style="padding:50px;">
							<i class="fas fa-file-alt fa-3x text-muted mb-3"></i>
							<p class="text-muted">选择一个文件进行预览</p>
						</div>
					}
				</div>
			</div>
		</div>
	}
</div>

@code {
	/// <summary>
	/// 会话ID参数
	/// </summary>
	[Parameter] public string? SessionId { get; set; }

	/// <summary>
	/// 可用的代理工具列表
	/// </summary>
	private List<OpenManus.Host.Services.Tools.IAgentTool> availableTools = new();

	/// <summary>
	/// 代理记忆对象
	/// </summary>
	private AgentMemory? agentMemory;

	/// <summary>
	/// 当前执行结果
	/// </summary>
	private AgentExecutionResult? currentExecution;

	/// <summary>
	/// 当前输入的消息
	/// </summary>
	private string currentMessage = string.Empty;

	/// <summary>
	/// 是否正在处理任务
	/// </summary>
	private bool isProcessing = false;

	/// <summary>
	/// 当前会话ID
	/// </summary>
	private string currentSessionId = "agent-session";

	/// <summary>
	/// 会话记忆字典，存储多个会话的记忆
	/// </summary>
	private Dictionary<string, AgentMemory> sessionMemories = new();

	/// <summary>
	/// 文件预览模态框是否可见
	/// </summary>
	private bool isFilePreviewModalVisible = false;

	/// <summary>
	/// 是否正在加载文件
	/// </summary>
	private bool isLoadingFile = false;

	/// <summary>
	/// 当前预览的文件信息
	/// </summary>
	private FilePreviewInfo? currentPreviewFile;

	/// <summary>
	/// 对话会话列表
	/// </summary>
	private List<ChatSession> chatSessions = new();

	/// <summary>
	/// 文件预览信息类
	/// </summary>
	public class FilePreviewInfo
	{
		/// <summary>
		/// 文件名
		/// </summary>
		public string Name { get; set; } = string.Empty;

		/// <summary>
		/// 文件路径
		/// </summary>
		public string Path { get; set; } = string.Empty;

		/// <summary>
		/// 文件内容
		/// </summary>
		public string Content { get; set; } = string.Empty;
	}

	/// <summary>
	/// 聊天会话类
	/// </summary>
	public class ChatSession
	{
		/// <summary>
		/// 会话ID
		/// </summary>
		public string Id { get; set; } = string.Empty;

		/// <summary>
		/// 会话标题
		/// </summary>
		public string Title { get; set; } = string.Empty;

		/// <summary>
		/// 最后活动时间
		/// </summary>
		public DateTime LastActivity { get; set; }

		/// <summary>
		/// 消息数量
		/// </summary>
		public int MessageCount { get; set; }
	}

	/// <summary>
	/// 组件初始化时的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	protected override async Task OnInitializedAsync()
	{
		await Task.CompletedTask; // 避免async警告

		availableTools = AgentService.GetAvailableTools();

		// 设置当前会话ID
		if (!string.IsNullOrEmpty(SessionId))
		{
			currentSessionId = SessionId;
		}

		// 加载会话记忆
		LoadSessionMemory();

		// 初始化对话历史（这里可以从持久化存储加载）
		LoadChatSessions();
	}

	/// <summary>
	/// 当组件参数设置时调用的方法
	/// </summary>
	/// <returns>任务</returns>
	protected override Task OnParametersSetAsync()
	{
		// 当参数变化时更新会话
		if (!string.IsNullOrEmpty(SessionId) && SessionId != currentSessionId)
		{
			currentSessionId = SessionId;
			LoadSessionMemory();
			StateHasChanged();
		}
		return Task.CompletedTask;
	}

	/// <summary>
	/// 执行用户任务的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task ExecuteTask()
	{
		if (string.IsNullOrWhiteSpace(currentMessage) || isProcessing)
			return;

		isProcessing = true;
		var userMessage = currentMessage.Trim();
		currentMessage = string.Empty;
		await InvokeAsync(StateHasChanged);

		try
		{
			// 获取或创建当前会话的内存
			if (!sessionMemories.ContainsKey(currentSessionId))
			{
				sessionMemories[currentSessionId] = new AgentMemory();
			}
			agentMemory = sessionMemories[currentSessionId];

			// 添加用户消息
			agentMemory.AddMessage("user", userMessage);

			// 初始化执行状态
			currentExecution = new AgentExecutionResult
			{
				SessionId = currentSessionId,
				Steps = new List<string>(),
				IsCompleted = false
			};

			// 强制UI更新
			await InvokeAsync(StateHasChanged);

			// 滚动到底部
			await Task.Delay(100); // 等待DOM更新
			await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");

			// 执行任务并实时更新步骤
			var result = await ExecuteTaskWithRealTimeUpdates(userMessage);

			// 更新最终执行状态
			currentExecution = result;

			// 如果有最终结果，添加到消息历史
			if (!string.IsNullOrEmpty(result.FinalResult))
			{
				agentMemory.AddMessage("assistant", result.FinalResult);
			}

			// 强制UI更新
			await InvokeAsync(StateHasChanged);

			// 再次滚动到底部
			await Task.Delay(100); // 等待DOM更新
			await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");
		}
		catch (Exception ex)
		{
			if (currentExecution != null)
			{
				currentExecution.Error = ex.Message;
				currentExecution.IsCompleted = true;
			}
			agentMemory?.AddMessage("assistant", $"执行任务时发生错误: {ex.Message}");
			await InvokeAsync(StateHasChanged);
			await Task.Delay(100);
			await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");
		}
		finally
		{
			isProcessing = false;
			await InvokeAsync(StateHasChanged);
		}
	}

	/// <summary>
	/// 执行任务并实时更新步骤
	/// </summary>
	/// <param name="userMessage">用户消息</param>
	/// <returns>执行结果</returns>
	private async Task<AgentExecutionResult> ExecuteTaskWithRealTimeUpdates(string userMessage)
	{
		var memory = AgentService.GetSession(currentSessionId);
		var result = new AgentExecutionResult
		{
			SessionId = currentSessionId,
			Steps = new List<string>()
		};

		try
		{
			// 添加初始步骤
			result.Steps.Add("开始处理用户请求...");
			currentExecution.Steps = new List<string>(result.Steps);
			await InvokeAsync(StateHasChanged);
			await Task.Delay(500); // 模拟处理时间

			// 分析用户意图
			result.Steps.Add("正在分析用户意图和需求...");
			currentExecution.Steps = new List<string>(result.Steps);
			await InvokeAsync(StateHasChanged);
			await Task.Delay(800); // 模拟处理时间

			// 选择合适的工具
			result.Steps.Add("正在选择合适的工具和方法...");
			currentExecution.Steps = new List<string>(result.Steps);
			await InvokeAsync(StateHasChanged);
			await Task.Delay(600); // 模拟处理时间

			// 执行具体任务
			result.Steps.Add("正在执行具体任务...");
			currentExecution.Steps = new List<string>(result.Steps);
			await InvokeAsync(StateHasChanged);

			// 调用原始的AgentService方法
			var originalResult = await AgentService.ExecuteTaskAsync(SessionId ?? currentSessionId, userMessage);

			// 合并步骤
			foreach (var step in originalResult.Steps)
			{
				result.Steps.Add(step);
				currentExecution.Steps = new List<string>(result.Steps);
				await InvokeAsync(StateHasChanged);
				await Task.Delay(300); // 每个步骤之间的延迟
			}

			// 完成任务
			result.Steps.Add("任务执行完成！");
			result.IsCompleted = true;
			result.FinalResult = originalResult.FinalResult;
			result.Error = originalResult.Error;

			currentExecution.Steps = new List<string>(result.Steps);
			currentExecution.IsCompleted = true;
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			result.Steps.Add($"执行过程中发生错误: {ex.Message}");
			result.Error = ex.Message;
			result.IsCompleted = true;

			currentExecution.Steps = new List<string>(result.Steps);
			currentExecution.Error = ex.Message;
			currentExecution.IsCompleted = true;
			await InvokeAsync(StateHasChanged);
		}

		return result;
	}

	/// <summary>
	/// 处理键盘按键事件
	/// </summary>
	/// <param name="e">键盘事件参数</param>
	/// <returns>异步任务</returns>
	private async Task HandleKeyPress(KeyboardEventArgs e)
	{
		// 按键处理现在主要在AgentInputArea组件中进行
		// 这里保留方法以供组件回调使用
		await Task.CompletedTask;
	}

	/// <summary>
	/// 清空当前会话的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task ClearSession()
	{
		await Task.CompletedTask; // 避免async警告

		AgentService.ClearSession(currentSessionId);
		agentMemory = AgentService.GetSession(currentSessionId);
		currentExecution = null;

		// 清空当前会话的记忆
		if (agentMemory != null)
		{
			sessionMemories[currentSessionId] = agentMemory;
		}

		StateHasChanged();
	}

	/// <summary>
	/// 根据消息角色获取对应的CSS类名
	/// </summary>
	/// <param name="role">消息角色</param>
	/// <returns>CSS类名</returns>
	private string GetMessageClass(string role)
	{
		return role switch
		{
			"user" => "user-message",
			"assistant" => "ai-message",
			"tool" => "tool-message",
			_ => "system-message"
		};
	}

	/// <summary>
	/// 格式化消息内容
	/// </summary>
	/// <param name="content">原始消息内容</param>
	/// <returns>格式化后的HTML内容</returns>
	private string FormatMessageContent(string content)
	{
		// 简单的格式化 - 将换行符转换为HTML
		return content.Replace("\n", "<br/>");
	}

	/// <summary>
	/// 滚动到消息底部的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task ScrollToBottom()
	{
		await Task.Delay(100);
		await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agent-messages");
	}

	/// <summary>
	/// 加载聊天会话列表
	/// </summary>
	private void LoadChatSessions()
	{
		// 这里可以从持久化存储加载对话历史
		// 暂时创建一些示例数据
		chatSessions = new List<ChatSession>
		{
			new ChatSession
			{
				Id = "session-1",
				Title = "文件处理任务",
				LastActivity = DateTime.Now.AddHours(-2),
				MessageCount = 5
			},
			new ChatSession
			{
				Id = "session-2",
				Title = "代码生成",
				LastActivity = DateTime.Now.AddDays(-1),
				MessageCount = 8
			}
		};
	}

	/// <summary>
	/// 加载当前会话的记忆
	/// </summary>
	private void LoadSessionMemory()
	{
		// 加载当前会话的记忆
		if (sessionMemories.ContainsKey(currentSessionId))
		{
			agentMemory = sessionMemories[currentSessionId];
		}
		else
		{
			agentMemory = AgentService.GetSession(currentSessionId);
			if (agentMemory != null)
			{
				sessionMemories[currentSessionId] = agentMemory;
			}
		}
	}

	/// <summary>
	/// 保存当前会话的记忆
	/// </summary>
	private void SaveSessionMemory()
	{
		// 保存当前会话的记忆
		if (agentMemory != null)
		{
			sessionMemories[currentSessionId] = agentMemory;
		}
	}

	/// <summary>
	/// 开始新的聊天会话
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task StartNewChat()
	{
		var newSessionId = $"session-{DateTime.Now.Ticks}";
		var newSession = new ChatSession
			{
				Id = newSessionId,
				Title = "新对话",
				LastActivity = DateTime.Now,
				MessageCount = 0
			};

		chatSessions.Insert(0, newSession);
		currentSessionId = newSessionId;

		// 清空当前会话
		agentMemory = AgentService.GetSession(currentSessionId);
		currentExecution = null;

		StateHasChanged();
		await Task.CompletedTask;
	}

	/// <summary>
	/// 切换到指定的会话
	/// </summary>
	/// <param name="sessionId">会话ID</param>
	/// <returns>异步任务</returns>
	private async Task SwitchToSession(string sessionId)
	{
		currentSessionId = sessionId;
		agentMemory = AgentService.GetSession(currentSessionId);
		currentExecution = null;

		StateHasChanged();
		await Task.CompletedTask;
	}

	/// <summary>
	/// 显示文件预览
	/// </summary>
	/// <param name="fileName">文件名</param>
	/// <param name="filePath">文件路径</param>
	/// <returns>异步任务</returns>
	private async Task ShowFilePreview(string fileName, string filePath)
	{
		try
		{
			// 这里可以添加实际的文件内容读取逻辑
			string fileContent = await LoadFileContent(filePath);

			// 通过JavaScript调用MainLayout的文件预览功能
			await JSRuntime.InvokeVoidAsync("showFilePreview", fileName, filePath, fileContent);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"显示文件预览失败: {ex.Message}");
			// 使用默认内容
			await JSRuntime.InvokeVoidAsync("showFilePreview", fileName, filePath, $"// 无法加载文件内容\n// 文件: {fileName}\n// 路径: {filePath}");
		}
	}

	/// <summary>
	/// 加载文件内容
	/// </summary>
	/// <param name="filePath">文件路径</param>
	/// <returns>文件内容字符串</returns>
	private async Task<string> LoadFileContent(string filePath)
	{
		// 这里应该实现实际的文件读取逻辑
		// 目前返回示例内容
		await Task.Delay(100); // 模拟异步操作

		return $"// 文件内容示例\n// 文件路径: {filePath}\n// 加载时间: {DateTime.Now}\n\n// 这里是文件的实际内容\nconsole.log('Hello from {System.IO.Path.GetFileName(filePath)}');";
	}

	/// <summary>
	/// 关闭文件预览
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task CloseFilePreview()
	{
		// 通过JavaScript关闭MainLayout的文件预览面板
		await JSRuntime.InvokeVoidAsync("closeFilePreview");
	}

	/// <summary>
	/// 检测内容中是否包含文件引用
	/// </summary>
	/// <param name="content">要检测的内容</param>
	/// <returns>是否包含文件引用</returns>
	private bool ContainsFileReference(string content)
	{
		// 简单的文件引用检测，可以根据实际需求调整
		return content.Contains("创建文件") || content.Contains("生成文件") ||
						content.Contains(".cs") || content.Contains(".js") ||
						content.Contains(".html") || content.Contains(".css") ||
						content.Contains(".txt") || content.Contains(".json");
	}

	/// <summary>
	/// 从内容中提取文件引用
	/// </summary>
	/// <param name="content">要分析的内容</param>
	/// <returns>文件引用列表</returns>
	private List<(string Name, string Path)> ExtractFileReferences(string content)
	{
		var fileRefs = new List<(string Name, string Path)>();

		// 使用正则表达式提取文件引用
		var filePattern = @"([\w\-\.]+\.(cs|js|html|css|txt|json|md|xml|yml|yaml))";
		var matches = System.Text.RegularExpressions.Regex.Matches(content, filePattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase);

		foreach (System.Text.RegularExpressions.Match match in matches)
		{
			var fileName = match.Value;
			var filePath = $"/temp/{fileName}"; // 假设的文件路径，实际应该从上下文获取

			if (!fileRefs.Any(f => f.Name == fileName))
			{
				fileRefs.Add((fileName, filePath));
			}
		}

		return fileRefs;
	}

	/// <summary>
	/// 组件渲染完成后的异步方法
	/// </summary>
	/// <param name="firstRender">是否为首次渲染</param>
	/// <returns>异步任务</returns>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await JSRuntime.InvokeVoidAsync("initModernUI");
		}
		// 每次渲染后自动滚动到底部（仅有消息时）
		if (agentMemory != null && agentMemory.Messages.Any())
		{
			await JSRuntime.InvokeVoidAsync("scrollToBottom", "agentMessages");
		}
	}
	/// <summary>
	/// 已选择的文件列表
	/// </summary>
	private List<IBrowserFile> selectedFiles = new();

	/// <summary>
	/// 文件选择事件处理方法
	/// </summary>
	/// <param name="e">文件选择事件参数</param>
	private void OnFileSelected(InputFileChangeEventArgs e)
	{
		selectedFiles = e.GetMultipleFiles().ToList();
	}

	/// <summary>
	/// 打开文件预览模态框
	/// </summary>
	private void OpenFilePreviewModal()
	{
		isFilePreviewModalVisible = true;
		StateHasChanged();
	}

	/// <summary>
	/// 关闭文件预览模态框
	/// </summary>
	private void CloseFilePreviewModal()
	{
		isFilePreviewModalVisible = false;
		StateHasChanged();
	}

	/// <summary>
	/// 加载文件预览内容
	/// </summary>
	/// <param name="filePath">文件路径</param>
	/// <returns>异步任务</returns>
	private async Task LoadFilePreview(string filePath)
	{
		isLoadingFile = true;
		StateHasChanged();

		try
		{
			if (File.Exists(filePath))
			{
				var content = await File.ReadAllTextAsync(filePath);
				currentPreviewFile = new FilePreviewInfo
					{
						Name = Path.GetFileName(filePath),
						Path = filePath,
						Content = content
					};
			}
		}
		catch (Exception ex)
		{
			currentPreviewFile = new FilePreviewInfo
				{
					Name = Path.GetFileName(filePath),
					Path = filePath,
					Content = $"无法加载文件内容: {ex.Message}"
				};
		}
		finally
		{
			isLoadingFile = false;
			StateHasChanged();
		}
	}
}