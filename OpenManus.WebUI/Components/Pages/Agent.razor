@page "/"
@page "/agent"
@page "/agent/{SessionId}"
@using OpenManus.WebUI.Models
@using OpenManus.WebUI.Services
@using System.Runtime.InteropServices

@inject AgentService AgentService
@inject IChatHistoryService ChatHistoryService
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@rendermode InteractiveServer

<PageTitle>OpenManus Agent</PageTitle>
<div class="agent-content" style="display:flex;flex-direction:column;height:calc(100vh - 56px);position:relative;">
	<!-- 主内容区域 -->
	<div class="main-chat-area" style="@(isFilePreviewModalVisible ? "margin-right:400px;" : "")">
		<!-- 消息显示区域 -->
		<div class="messages-container" style="overflow-y:auto;flex-shrink:0;">
			@if (agentMemory == null || !agentMemory.Messages.Any())
			{
				<div class="welcome-message">
					<div class="welcome-content">
						<i class="fas fa-robot fa-3x text-primary mb-1"></i>
						<h5>欢迎使用 OpenManus AI Agent</h5>
						<p>我是一个多功能AI助手，可以帮助您：</p>
						<ul class="feature-list">
							<li><i class="fas fa-file"></i> 文件操作和管理</li>
							<li><i class="fab fa-python"></i> Python代码执行</li>
							<li><i class="fas fa-search"></i> 信息搜索</li>
							<li><i class="fas fa-tasks"></i> 复杂任务规划和执行</li>
						</ul>
						<p>请输入您的任务或问题，我将为您提供帮助。</p>
					</div>
				</div>
			}
			else
			{
				@* 
					AI代理主页面组件 - 应用程序的核心交互界面
					提供与AI代理的对话功能、文件预览、任务执行状态显示
					支持多会话管理、实时消息流、工具调用结果展示和文件操作
				*@
				<!-- 内容流式输出展示区，实时滚动定位到底部 -->
				<div class="agent-messages" id="agentMessages">
					@foreach (var message in agentMemory.Messages.Where(m => m.Role != "system"))
					{
						<div class="message @GetMessageClass(message.Role)">
							<div class="message-avatar">
								@if (message.Role == "user")
								{
									<i class="fas fa-user"></i>
								}
								else if (message.Role == "assistant")
								{
									<i class="fas fa-robot"></i>
								}
								else if (message.Role == "tool")
								{
									<i class="fas fa-cog"></i>
								}
							</div>
							<div class="message-content">
								<div class="message-text">
									@if (message.Role == "tool")
									{
										<div class="tool-result">
											<strong>工具执行结果:</strong>
											<pre>@message.Content</pre>
										</div>
									}
									else
									{
										@((MarkupString)FormatMessageContent(message.Content))
										@if (message.Role == "assistant" && ContainsFileReference(message.Content))
										{
											<div class="file-actions">
												@foreach (var fileRef in ExtractFileReferences(message.Content))
												{
													<button class="btn btn-sm btn-outline-primary file-preview-btn"
															@onclick="() => ShowFilePreview(fileRef.Name, fileRef.Path)">
														<i class="fas fa-eye"></i> 预览 @fileRef.Name
													</button>
												}
											</div>
										}
									}
								</div>
								<div class="message-time">@message.Timestamp.ToString("HH:mm:ss")</div>
							</div>
						</div>
					}
				</div>
			}

		</div>

		@* 底部输入区域容器 *@
		<div id="bottom-area" style="position: absolute; bottom: 10px;margin-top: 240px; left: 0; right: 0; z-index: 999;">
			@* 任务执行状态组件 *@
			<ExecutionStatusDock ExecutionResult="@currentExecution" Messages="@agentMemory?.Messages" />
			<!-- 输入框区域 -->
			<AgentInputArea CurrentMessage="@currentMessage"
							CurrentMessageChanged="@(value => { currentMessage = value; StateHasChanged(); })"
							IsProcessing="@isProcessing"
							IsFilePreviewVisible="@isFilePreviewModalVisible"
							SelectedFiles="@selectedFiles"
							OnExecuteTask="@ExecuteTask"
							OnOpenFilePreview="@OpenFilePreviewModal"
							OnFileSelected="@OnFileSelected"
							OnKeyPress="@HandleKeyPress" />
		</div>
	</div>

	<!-- 右侧文件预览面板 -->
	@if (isFilePreviewModalVisible)
	{
		<div class="file-preview-sidebar" style="transform:translateX(@(isFilePreviewModalVisible ? "0" : "100%"));">
			<div class="sidebar-header" style="padding:15px;border-bottom:1px solid #333;display:flex;justify-content:space-between;align-items:center;">
				<h5 class="mb-0 text-light">
					<i class="fas fa-file-alt"></i> 文件预览
				</h5>
				<button type="button" class="btn btn-outline-light btn-sm" @onclick="CloseFilePreviewModal">
					<i class="fas fa-times"></i>
				</button>
			</div>
			<div class="sidebar-body" style="height:calc(100vh - 70px);overflow:hidden;">
				<div class="file-preview-content" style="height:100%;display:flex;flex-direction:column;">
					@if (currentPreviewFile != null)
					{
						<div class="file-info" style="padding:15px;border-bottom:1px solid #333;flex-shrink:0;">
							<h6 class="text-light"><i class="fas fa-file-alt"></i> @currentPreviewFile.Name</h6>
							<p class="file-path text-muted mb-0 small">@currentPreviewFile.Path</p>
						</div>
						<div class="file-content" style="flex:1;overflow:auto;padding:15px;">
							@if (isLoadingFile)
							{
								<div class="loading-spinner text-center">
									<i class="fas fa-spinner fa-spin fa-2x text-light"></i>
									<p class="mt-2 text-light">正在加载文件内容...</p>
								</div>
							}
							else
							{
								<pre style="background:#2d2d2d;color:#f8f8f2;padding:15px;border-radius:5px;margin:0;white-space:pre-wrap;word-wrap:break-word;font-size:12px;line-height:1.4;"><code>@currentPreviewFile.Content</code></pre>
							}
						</div>
					}
					else
					{
						<div class="no-file-selected text-center" style="padding:50px;">
							<i class="fas fa-file-alt fa-3x text-muted mb-3"></i>
							<p class="text-muted">选择一个文件进行预览</p>
						</div>
					}
				</div>
			</div>
		</div>
	}
</div>

<style>
	.main-chat-area {
		flex: 1;
		display: flex;
		flex-direction: column;
		position: relative;
		transition: margin-right 0.3s ease;
		max-width: 900px;
	}

	.file-preview-sidebar {
		position: fixed;
		top: 0;
		right: 0;
		width: calc(100vw - var(--main-chat-area-width,1230px));
		height: calc(100vh - 95px);
		background: #1e1e1e;
		border-left: 1px solid #333;
		z-index: 1001;
		transition: transform 0.3s ease;
		padding: 20px 20px 0px 0px;
		margin: 64px 10px 10px 0px;
		border-radius: 5px;
	}
</style>

<script>
	// 封装函数：更新 CSS 变量 --bottom-area-height
	function updateBottomAreaHeight() {
		const bottomArea = document.getElementById('bottom-area');
		if (bottomArea) {
			const height = bottomArea.offsetHeight + 60;
			document.documentElement.style.setProperty('--bottom-area-height', height + 'px');
		}
	}

	// 调整 main 内容高度：根据 bottom-area 高度
	function adjustMainHeight() {
		const main = document.getElementById('main');
		const bottomHeight = getComputedStyle(document.documentElement)
			.getPropertyValue('--bottom-area-height')
			.trim()
			.replace('px', '') || '0';
		const topHeight = 56; // 顶部导航高度，可根据实际情况设置
		const calcHeight = `calc(100vh - ${topHeight}px - ${bottomHeight}px)`;
		if (main) {
			main.style.height = calcHeight;
		}
	}

	// 初始化 & 监听
	function initDynamicLayout() {
		const bottomArea = document.getElementById('bottom-area');

		// 初始设置
		updateBottomAreaHeight();
		adjustMainHeight();

		// ResizeObserver 监听 bottom 区域高度变化
		if (bottomArea && window.ResizeObserver) {
			const resizeObserver = new ResizeObserver(() => {
				updateBottomAreaHeight();
				adjustMainHeight();
			});
			resizeObserver.observe(bottomArea);
		}

		// 备用方案：每 500ms 检查一次
		setInterval(() => {
			updateBottomAreaHeight();
			adjustMainHeight();
		}, 500);

		// 窗口尺寸变化时也更新
		window.addEventListener('resize', () => {
			updateBottomAreaHeight();
			adjustMainHeight();
		});
	}

	// 页面加载完成后启动
	window.addEventListener('load', initDynamicLayout);
</script>

@code {
	/// <summary>
	/// 会话ID参数
	/// </summary>
	[Parameter] public string? SessionId { get; set; }

	/// <summary>
	/// 可用的代理工具列表
	/// </summary>
	private List<OpenManus.WebUI.Services.Tools.IAgentTool> availableTools = new();

	/// <summary>
	/// 代理记忆对象
	/// </summary>
	private AgentMemory? agentMemory;

	/// <summary>
	/// 当前输入的消息
	/// </summary>
	private string currentMessage = string.Empty;

	/// <summary>
	/// 是否正在处理任务
	/// </summary>
	private bool isProcessing = false;

	/// <summary>
	/// 当前任务执行状态
	/// </summary>
	private AgentExecutionResult? currentExecution = null;

	/// <summary>
	/// 当前会话ID
	/// </summary>
	private string currentSessionId = "agent-session";

	/// <summary>
	/// 会话记忆字典，存储多个会话的记忆
	/// </summary>
	private Dictionary<string, AgentMemory> sessionMemories = new();

	/// <summary>
	/// 文件预览模态框是否可见
	/// </summary>
	private bool isFilePreviewModalVisible = false;

	/// <summary>
	/// 是否正在加载文件
	/// </summary>
	private bool isLoadingFile = false;

	/// <summary>
	/// 当前预览的文件信息
	/// </summary>
	private FilePreviewInfo? currentPreviewFile;



	/// <summary>
	/// 文件预览信息类
	/// </summary>
	public class FilePreviewInfo
	{
		/// <summary>
		/// 文件名
		/// </summary>
		public string Name { get; set; } = string.Empty;

		/// <summary>
		/// 文件路径
		/// </summary>
		public string Path { get; set; } = string.Empty;

		/// <summary>
		/// 文件内容
		/// </summary>
		public string Content { get; set; } = string.Empty;
	}

	/// <summary>
	/// 组件初始化时的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	protected override async Task OnInitializedAsync()
	{
		availableTools = AgentService.GetAvailableTools();

		// 设置当前会话ID
		if (string.IsNullOrEmpty(SessionId))
		{
			currentSessionId = Guid.NewGuid().ToString();
		}
		else
		{
			currentSessionId = SessionId;
		}

		// 加载会话记忆
		await LoadSessionMemoryAsync();

		// 强制触发UI更新以显示加载的数据
		await InvokeAsync(StateHasChanged);
	}

	/// <summary>
	/// 组件渲染后调用的方法
	/// </summary>
	/// <param name="firstRender">是否为首次渲染</param>
	/// <returns>异步任务</returns>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			// 初始化底部区域高度计算
			await JSRuntime.InvokeVoidAsync("updateBottomAreaHeight");
		}

		// 每次渲染后自动滚动到底部（仅有消息时）
		if (agentMemory != null && agentMemory.Messages.Any())
		{
			await JSRuntime.InvokeVoidAsync("scrollToBottom", "agentMessages");
		}
		await base.OnAfterRenderAsync(firstRender);
	}
	/// <summary>
	/// 当组件参数设置时调用的方法
	/// </summary>
	/// <returns>任务</returns>
	protected override async Task OnParametersSetAsync()
	{
		try
		{
			Console.WriteLine($"=== OnParametersSetAsync 被调用 ===\nSessionId: '{SessionId}'\ncurrentSessionId: '{currentSessionId}'\n时间: {DateTime.Now}");

			// 如果SessionId为空，使用默认值
			var targetSessionId = string.IsNullOrEmpty(SessionId) ? "default-session" : SessionId;

			Console.WriteLine($"目标会话ID: '{targetSessionId}'");

			// 检查是否需要切换会话
			if (targetSessionId != currentSessionId)
			{
				Console.WriteLine($"会话ID发生变化，从 '{currentSessionId}' 切换到 '{targetSessionId}'");

				var previousSessionId = currentSessionId;
				currentSessionId = targetSessionId;

				Console.WriteLine("开始加载新会话数据...");
				await LoadSessionMemoryAsync();

				Console.WriteLine($"会话数据加载完成，消息数量: {agentMemory?.Messages?.Count ?? 0}");

				// 强制触发UI重新渲染以显示新会话的历史数据
				await InvokeAsync(StateHasChanged);

				Console.WriteLine("UI状态已更新");
			}
			else
			{
				Console.WriteLine("会话ID未变化，跳过加载");
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine($"OnParametersSetAsync 错误: {ex.Message}\n{ex.StackTrace}");
		}
	}


	/// <summary>
	/// 执行用户任务的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task ExecuteTask()
	{
		if (string.IsNullOrWhiteSpace(currentMessage) || isProcessing)
			return;
		var tempAgentMemory = new AgentMemory();
		isProcessing = true;
		var userMessage = currentMessage.Trim();
		currentMessage = string.Empty;
		await InvokeAsync(StateHasChanged);

		try
		{
			// 创建执行状态
			currentExecution = new AgentExecutionResult
				{
					SessionId = currentSessionId,
					Steps = new List<string> { "正在处理用户请求..." },
					IsCompleted = false
				};
			await InvokeAsync(StateHasChanged);
			// 更新底部区域高度
			await JSRuntime.InvokeVoidAsync("updateBottomAreaHeight");

			// 获取当前会话的内存（如果当前内存为空或消息数量为0才重新加载）
			if (tempAgentMemory == null || tempAgentMemory.Messages.Count == 0)
			{
				tempAgentMemory = await ChatHistoryService.GetSessionMemoryAsync(currentSessionId);
				if (tempAgentMemory == null)
				{
					tempAgentMemory = new AgentMemory();
				}
				sessionMemories[currentSessionId] = tempAgentMemory;
			}

			// 添加用户消息并实时保存
			var userMsg = new AgentMessage
				{
					OrderBy = tempAgentMemory.Messages.Count + 1,
					Role = "user",
					Content = userMessage,
					Timestamp = DateTime.UtcNow
				};
			// 只保存到持久化存储，内存会在下次加载时同步，并返回
			tempAgentMemory = await ChatHistoryService.AddMessageAsync(currentSessionId, userMsg);
			currentExecution.Steps.Add("用户消息已添加到会话记忆并保存");
			await InvokeAsync(StateHasChanged);

			// 强制UI更新
			await InvokeAsync(StateHasChanged);

			// 滚动到底部
			await Task.Delay(100); // 等待DOM更新
			await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");

			// 更新执行状态
			currentExecution.Steps.Add("正在连接AI服务...");
			await InvokeAsync(StateHasChanged);

			// 添加一个空的助手消息用于流式显示
			var assistantMessage = new AgentMessage
				{
					OrderBy = tempAgentMemory.Messages.Count + 1,
					Role = "assistant",
					Content = "",
					Timestamp = DateTime.UtcNow
				};
			// 先添加到内存用于流式显示

			// 强制UI更新以显示空的助手消息
			await InvokeAsync(StateHasChanged);
			await Task.Delay(100);
			await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");

			currentExecution.Steps.Add("开始接收AI响应...");
			await InvokeAsync(StateHasChanged);

			// 使用流式API获取响应
			var (response, usage) = await AgentService.StreamAIResponseAsync(
				tempAgentMemory,
				async (deltaContent) =>
				{
					// 实时更新助手消息内容
					assistantMessage.Content += deltaContent;
					Console.WriteLine($"助手消息内容已更新: {assistantMessage.Content}");
					await InvokeAsync(StateHasChanged);
					await Task.Delay(50); // 稍微延迟以获得更好的视觉效果
					await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");
				}
			);
			tempAgentMemory.Messages.Add(assistantMessage);

			// 更新最终的消息内容
			assistantMessage.Content = response.Content;
			tempAgentMemory = await ChatHistoryService.AddMessageAsync(currentSessionId, assistantMessage);

			// 如果有使用情况统计，可以保存到消息的元数据中
			if (usage != null)
			{
				assistantMessage.Metadata = new Dictionary<string, object>
					{
						["usage"] = usage
					};
			}

			// 保存助手消息到聊天历史服务（只保存一次）

			// 更新执行状态为完成
			currentExecution.Steps.Add("AI响应接收完成并保存");
			currentExecution.IsCompleted = true;
			currentExecution.FinalResult = $"成功生成回复，共 {response.Content.Length} 个字符";
			if (usage != null)
			{
				currentExecution.Usage = usage;
			}

			// 强制UI更新
			await InvokeAsync(StateHasChanged);

			// 更新底部区域高度
			await JSRuntime.InvokeVoidAsync("updateBottomAreaHeight");

			// 滚动到底部
			await Task.Delay(100);
			await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");
		}
		catch (Exception ex)
		{
			// 添加错误消息到内存和持久化存储
			var errorMessage = new AgentMessage
				{
					OrderBy = tempAgentMemory.Messages.Count + 1,
					Role = "assistant",
					Content = $"执行任务时发生错误: {ex.Message}",
					Timestamp = DateTime.UtcNow
				};

			if (tempAgentMemory != null)
			{
				// 只保存到持久化存储，同时添加到当前内存
				tempAgentMemory = await ChatHistoryService.AddMessageAsync(currentSessionId, errorMessage);
			}

			// 更新执行状态为错误
			if (currentExecution != null)
			{
				currentExecution.Steps.Add("执行过程中发生错误并已保存");
				currentExecution.IsCompleted = true;
				currentExecution.Error = ex.Message;
			}

			await InvokeAsync(StateHasChanged);
			await Task.Delay(100);
			await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agentMessages");
		}
		finally
		{
			isProcessing = false;

			// 确保执行状态最终被标记为完成
			if (currentExecution != null && !currentExecution.IsCompleted)
			{
				currentExecution.IsCompleted = true;
				currentExecution.Steps.Add("任务执行结束");
			}

			await InvokeAsync(StateHasChanged);
			agentMemory = tempAgentMemory;
		}
	}



	/// <summary>
	/// 处理键盘按键事件
	/// </summary>
	/// <param name="e">键盘事件参数</param>
	/// <returns>异步任务</returns>
	private async Task HandleKeyPress(KeyboardEventArgs e)
	{
		// 按键处理现在主要在AgentInputArea组件中进行
		// 这里保留方法以供组件回调使用
		await Task.CompletedTask;
	}

	/// <summary>
	/// 清空当前会话的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task ClearSession()
	{
		// 清空聊天历史服务中的会话数据
		await ChatHistoryService.ClearSessionAsync(currentSessionId);

		// 清空AgentService中的会话
		AgentService.ClearSession(currentSessionId);
		agentMemory = AgentService.GetSession(currentSessionId);

		// 清空当前会话的记忆
		if (agentMemory != null)
		{
			sessionMemories[currentSessionId] = agentMemory;
		}
		else
		{
			sessionMemories.Remove(currentSessionId);
		}

		StateHasChanged();
	}

	/// <summary>
	/// 根据消息角色获取对应的CSS类名
	/// </summary>
	/// <param name="role">消息角色</param>
	/// <returns>CSS类名</returns>
	private string GetMessageClass(string role)
	{
		return role switch
		{
			"user" => "user-message",
			"assistant" => "ai-message",
			"tool" => "tool-message",
			_ => "system-message"
		};
	}

	/// <summary>
	/// 格式化消息内容
	/// </summary>
	/// <param name="content">原始消息内容</param>
	/// <returns>格式化后的HTML内容</returns>
	private string FormatMessageContent(string content)
	{
		// 简单的格式化 - 将换行符转换为HTML
		return content.Replace("\n", "<br/>");
	}

	/// <summary>
	/// 滚动到消息底部的异步方法
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task ScrollToBottom()
	{
		await Task.Delay(100);
		await JSRuntime.InvokeVoidAsync("smoothScrollToBottom", "agent-messages");
	}

	/// <summary>
	/// 加载当前会话的记忆
	/// </summary>
	private async Task LoadSessionMemoryAsync()
	{
		try
		{
			// 从聊天历史服务加载当前会话的记忆
			if (sessionMemories.ContainsKey(currentSessionId))
			{
				agentMemory = sessionMemories[currentSessionId];
			}
			else
			{
				// 从聊天历史服务获取会话记忆
				agentMemory = await ChatHistoryService.GetSessionMemoryAsync(currentSessionId);
				if (agentMemory == null)
				{
					// 如果聊天历史服务中没有，则从AgentService获取
					agentMemory = AgentService.GetSession(currentSessionId);
				}

				// 确保agentMemory不为null
				if (agentMemory == null)
				{
					agentMemory = new AgentMemory();
				}

				sessionMemories[currentSessionId] = agentMemory;
			}

			// 记录加载的消息数量用于调试
			Console.WriteLine($"LoadSessionMemoryAsync: 会话 {currentSessionId} 加载了 {agentMemory?.Messages?.Count ?? 0} 条消息");
		}
		catch (Exception ex)
		{
			Console.WriteLine($"LoadSessionMemoryAsync 错误: {ex.Message}");
			// 创建新的会话内存作为后备
			agentMemory = new AgentMemory();
			sessionMemories[currentSessionId] = agentMemory;
		}
	}



	/// <summary>
	/// 保存当前会话的记忆
	/// </summary>
	private void SaveSessionMemory()
	{
		// 保存当前会话的记忆
		if (agentMemory != null)
		{
			sessionMemories[currentSessionId] = agentMemory;
		}
	}


	/// <summary>
	/// 显示文件预览
	/// </summary>
	/// <param name="fileName">文件名</param>
	/// <param name="filePath">文件路径</param>
	/// <returns>异步任务</returns>
	private async Task ShowFilePreview(string fileName, string filePath)
	{
		await LoadFilePreview(filePath);
		OpenFilePreviewModal();
	}

	/// <summary>
	/// 加载文件内容
	/// </summary>
	/// <param name="filePath">文件路径</param>
	/// <returns>文件内容字符串</returns>
	private async Task<string> LoadFileContent(string filePath)
	{
		// 这里应该实现实际的文件读取逻辑
		// 目前返回示例内容
		await Task.Delay(100); // 模拟异步操作

		return $"// 文件内容示例\n// 文件路径: {filePath}\n// 加载时间: {DateTime.Now}\n\n// 这里是文件的实际内容\nconsole.log('Hello from {System.IO.Path.GetFileName(filePath)}');";
	}

	/// <summary>
	/// 关闭文件预览
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task CloseFilePreview()
	{
		// 通过JavaScript关闭MainLayout的文件预览面板
		await JSRuntime.InvokeVoidAsync("closeFilePreview");
	}

	/// <summary>
	/// 检测内容中是否包含文件引用
	/// </summary>
	/// <param name="content">要检测的内容</param>
	/// <returns>是否包含文件引用</returns>
	private bool ContainsFileReference(string content)
	{
		// 简单的文件引用检测，可以根据实际需求调整
		return content.Contains("创建文件") || content.Contains("生成文件") ||
						content.Contains(".cs") || content.Contains(".js") ||
						content.Contains(".html") || content.Contains(".css") ||
						content.Contains(".txt") || content.Contains(".json");
	}

	/// <summary>
	/// 从内容中提取文件引用
	/// </summary>
	/// <param name="content">要分析的内容</param>
	/// <returns>文件引用列表</returns>
	private List<(string Name, string Path)> ExtractFileReferences(string content)
	{
		var fileRefs = new List<(string Name, string Path)>();

		// 使用正则表达式提取文件引用
		var filePattern = @"([\w\-\.]+\.(cs|js|html|css|txt|json|md|xml|yml|yaml))";
		var matches = System.Text.RegularExpressions.Regex.Matches(content, filePattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase);

		foreach (System.Text.RegularExpressions.Match match in matches)
		{
			var fileName = match.Value;
			var filePath = $"/temp/{fileName}"; // 假设的文件路径，实际应该从上下文获取

			if (!fileRefs.Any(f => f.Name == fileName))
			{
				fileRefs.Add((fileName, filePath));
			}
		}

		return fileRefs;
	}


	/// <summary>
	/// 已选择的文件列表
	/// </summary>
	private List<IBrowserFile> selectedFiles = new();

	/// <summary>
	/// 文件选择事件处理方法
	/// </summary>
	/// <param name="e">文件选择事件参数</param>
	private void OnFileSelected(InputFileChangeEventArgs e)
	{
		selectedFiles = e.GetMultipleFiles().ToList();
	}

	/// <summary>
	/// 打开文件预览模态框
	/// </summary>
	private void OpenFilePreviewModal()
	{
		isFilePreviewModalVisible = true;
		StateHasChanged();
	}

	/// <summary>
	/// 关闭文件预览模态框
	/// </summary>
	private void CloseFilePreviewModal()
	{
		isFilePreviewModalVisible = false;
		StateHasChanged();
	}

	/// <summary>
	/// 加载文件预览内容
	/// </summary>
	/// <param name="filePath">文件路径</param>
	/// <returns>异步任务</returns>
	private async Task LoadFilePreview(string filePath)
	{
		isLoadingFile = true;
		StateHasChanged();

		try
		{
			if (File.Exists(filePath))
			{
				var content = await File.ReadAllTextAsync(filePath);
				currentPreviewFile = new FilePreviewInfo
					{
						Name = Path.GetFileName(filePath),
						Path = filePath,
						Content = content
					};
			}
		}
		catch (Exception ex)
		{
			currentPreviewFile = new FilePreviewInfo
				{
					Name = Path.GetFileName(filePath),
					Path = filePath,
					Content = $"无法加载文件内容: {ex.Message}"
				};
		}
		finally
		{
			isLoadingFile = false;
			StateHasChanged();
		}
	}
}