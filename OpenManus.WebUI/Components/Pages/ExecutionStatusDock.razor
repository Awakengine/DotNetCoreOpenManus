@*
    执行状态停靠组件 - 显示任务执行进度和状态
    提供实时的任务执行步骤、完成状态、结果和错误信息显示
    支持动画效果和响应式布局
*@
@using OpenManus.WebUI.Models
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@if (IsVisible)
{
	<div class="execution-dock" @ref="executionDockRef">
		<div class="execution-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: @(isCollapsed ? "0" : "10px"); cursor: pointer;" @onclick="ToggleCollapse">
			<h6 style="color: white; margin: 0; font-weight: 600; font-size: 14px;">
				@if (ExecutionResult.IsCompleted)
				{
					<i class="fas fa-check-circle" style="color: #4CAF50;"></i>
				}
				else
				{
					<i class="fas fa-cog fa-spin" style="color: #FFC107;"></i>
				}
				任务执行状态
			</h6>
			<div style="display: flex; align-items: center; gap: 8px;">
				@if (ExecutionResult?.IsCompleted == true)
				{
					<span class="badge" style="background: #4CAF50; color: white; padding: 3px 8px; border-radius: 12px; font-size: 11px;">已完成</span>
				}
				else if (ExecutionResult != null)
				{
					<span class="badge" style="background: #FFC107; color: #333; padding: 3px 8px; border-radius: 12px; font-size: 11px; animation: pulse 2s infinite;">进行中</span>
				}
				<i class="fas @(isCollapsed ? "fa-chevron-down" : "fa-chevron-up")" style="color: white; font-size: 12px;"></i>
			</div>
		</div>
		@if (!isCollapsed)
		{
			<div class="execution-steps" style="background: rgba(255,255,255,0.1); border-radius: 6px; padding: 10px; backdrop-filter: blur(10px); max-height: 120px; overflow-y: auto;">
				@if (ExecutionResult?.Steps != null)
				{
					@for (int i = 0; i < ExecutionResult.Steps.Count; i++)
					{
						var step = ExecutionResult.Steps[i];
						var isLatest = i == ExecutionResult.Steps.Count - 1;
						<div class="execution-step" style="display: flex; align-items: center; margin: 4px 0; padding: 6px 8px; border-radius: 4px; background: @(isLatest && !ExecutionResult.IsCompleted ? "rgba(255,193,7,0.2)" : "rgba(255,255,255,0.05)"); transition: all 0.3s ease; @(isLatest && !ExecutionResult.IsCompleted ? "animation: stepHighlight 2s infinite;" : "")">
							<i class="fas @(ExecutionResult.IsCompleted || i < ExecutionResult.Steps.Count - 1 ? "fa-check-circle" : "fa-clock")" style="color: @(ExecutionResult.IsCompleted || i < ExecutionResult.Steps.Count - 1 ? "#4CAF50" : "#FFC107"); margin-right: 8px; font-size: 12px;"></i>
							<span style="color: white; font-size: 12px; flex: 1;">@step</span>
							@if (isLatest && !ExecutionResult.IsCompleted)
							{
								<div class="spinner-border spinner-border-sm" style="color: #FFC107; width: 12px; height: 12px;" role="status"></div>
							}
						</div>
					}
				}
			</div>
		}
		@if (!string.IsNullOrEmpty(ExecutionResult.FinalResult))
		{
			<div class="execution-result" style="background: rgba(76,175,80,0.1); border: 1px solid rgba(76,175,80,0.3); border-radius: 6px; padding: 10px; margin-top: 10px;">
				<strong style="color: #4CAF50; display: flex; align-items: center; margin-bottom: 5px; font-size: 12px;">
					<i class="fas fa-check-circle" style="margin-right: 6px;"></i>
					最终结果:
				</strong>
				<div class="result-content" style="color: white; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; font-family: 'Consolas', monospace; font-size: 11px; max-height: 60px; overflow-y: auto;">@ExecutionResult.FinalResult</div>
			</div>
		}
		@if (!string.IsNullOrEmpty(ExecutionResult.Error))
		{
			<div class="execution-error" style="background: rgba(244,67,54,0.1); border: 1px solid rgba(244,67,54,0.3); border-radius: 6px; padding: 10px; margin-top: 10px;">
				<strong style="color: #F44336; display: flex; align-items: center; margin-bottom: 5px; font-size: 12px;">
					<i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i>
					错误:
				</strong>
				<div class="error-content" style="color: #FFCDD2; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; font-family: 'Consolas', monospace; font-size: 11px; max-height: 60px; overflow-y: auto;">@ExecutionResult.Error</div>
			</div>
		}
	</div>
}

<style>
	.execution-dock {
		bottom: -10px !important;
		position: relative;
		background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		border-radius: 12px 12px 12px 12px;
		padding: 15px 20px;
		margin: 0 20px 8px px;
		box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
		border: 1px solid rgba(255,255,255,0.1);
		border-bottom: none;
	}

	@@keyframes pulse {
		0% {
			opacity: 1;
		}

		50% {
			opacity: 0.5;
		}

		100% {
			opacity: 1;
		}
	}

	@@keyframes stepHighlight {
		0% {
			background: rgba(255,193,7,0.2);
		}

		50% {
			background: rgba(255,193,7,0.4);
		}

		100% {
			background: rgba(255,193,7,0.2);
		}
	}
</style>

@code {
	/// <summary>
	/// 执行结果对象，包含任务执行的所有状态信息
	/// </summary>
	[Parameter] public AgentExecutionResult? ExecutionResult { get; set; }

	/// <summary>
	/// 执行结果变化时的回调事件
	/// </summary>
	[Parameter] public EventCallback<AgentExecutionResult?> ExecutionResultChanged { get; set; }

	/// <summary>
	/// 组件的CSS类名，用于自定义样式
	/// </summary>
	[Parameter] public string? CssClass { get; set; }

	/// <summary>
	/// 自定义样式字符串
	/// </summary>
	[Parameter] public string? Style { get; set; }

	/// <summary>
	/// 是否显示关闭按钮
	/// </summary>
	[Parameter] public bool ShowCloseButton { get; set; } = false;

	/// <summary>
	/// 关闭按钮点击时的回调事件
	/// </summary>
	[Parameter] public EventCallback OnClose { get; set; }

	/// <summary>
	/// 执行停靠区域的元素引用
	/// </summary>
	private ElementReference executionDockRef;

	/// <summary>
	/// 是否折叠状态
	/// </summary>
	private bool isCollapsed = false;

	/// <summary>
	/// 是否显示组件（永久停靠模式）
	/// </summary>
	public bool IsVisible => ExecutionResult != null || hasEverExecuted;

	/// <summary>
	/// 是否曾经执行过任务
	/// </summary>
	private bool hasEverExecuted = false;

	/// <summary>
	/// 组件渲染后调用，用于设置动态位置
	/// </summary>
	/// <param name="firstRender">是否为首次渲染</param>
	/// <returns>异步任务</returns>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (ExecutionResult != null)
		{
			await UpdatePosition();
		}
		await base.OnAfterRenderAsync(firstRender);
	}

	/// <summary>
	/// 参数设置后调用，用于更新位置
	/// </summary>
	/// <returns>异步任务</returns>
	protected override async Task OnParametersSetAsync()
	{
		await base.OnParametersSetAsync();
		if (ExecutionResult != null)
		{
			hasEverExecuted = true;
			await Task.Delay(50); // 等待DOM更新
			await UpdatePosition();
		}
	}

	/// <summary>
	/// 切换折叠状态
	/// </summary>
	private void ToggleCollapse()
	{
		isCollapsed = !isCollapsed;
		StateHasChanged();
	}

	/// <summary>
	/// 更新执行停靠区域的位置
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task UpdatePosition()
	{
		try
		{
			await JSRuntime.InvokeVoidAsync("updateExecutionDockPosition", executionDockRef);
		}
		catch (Exception)
		{
			// 忽略JavaScript调用错误
		}
	}

	/// <summary>
	/// 组件销毁时清理资源
	/// </summary>
	/// <param name="disposing">是否正在销毁</param>
	/// <returns>异步任务</returns>
	public async ValueTask DisposeAsync()
	{
		try
		{
			await JSRuntime.InvokeVoidAsync("cleanupExecutionDockObserver", executionDockRef);
		}
		catch (Exception)
		{
			// 忽略JavaScript调用错误
		}
	}

	/// <summary>
	/// 处理关闭按钮点击事件
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task HandleClose()
	{
		if (OnClose.HasDelegate)
		{
			await OnClose.InvokeAsync();
		}
	}
}