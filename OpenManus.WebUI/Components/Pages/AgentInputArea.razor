@* 
    智能助手输入区域组件 - 用户输入和文件上传界面
    提供消息输入、文件附件选择、任务执行等功能
    支持键盘快捷键操作和文件预览
*@
@using Microsoft.AspNetCore.Components.Forms
@using OpenManus.WebUI.Models
@using OpenManus.WebUI.Services
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject HttpClient HttpClient
@inject IConfigurationService ConfigurationService

<div class="agent-input-area-fixed"
	 style="position:relative;background:#1e1e1e;border-top:1px solid #333;">
	<!-- 输入框上方的控制按钮 -->
	<div class="input-controls" style="padding:8px 12px;border-bottom:1px solid #333;">
		@if (!IsFilePreviewVisible)
		{
			<button class="btn btn-outline-light btn-sm" title="文件预览" @onclick="OnOpenFilePreview">
				<i class="fas fa-expand"></i> 文件预览
			</button>
		}
	</div>

	<textarea class="form-control" placeholder="输入您的消息...（Shift+Enter 换行）"
			  @bind-value="CurrentMessage" @bind-value:event="oninput" @bind-value:after="OnCurrentMessageChanged"
			  @onkeydown="@(e => HandleKeyPress(e))" disabled="@IsProcessing" rows="6" @ref="textareaRef"></textarea>
	<div class="input-group align-items-end">
		<label class="btn btn-outline-secondary mb-0 me-2">
			<i class="fas fa-paperclip"></i>
			<InputFile OnChange="OnFileSelected" multiple style="display:none" @ref="fileInputRef" />
		</label>
		
		<!-- 模型选择下拉框 -->
		<div class="dropdown me-2">
			<button class="btn btn-outline-secondary dropdown-toggle" type="button" 
					id="modelDropdown" data-bs-toggle="dropdown" aria-expanded="false"
					disabled="@IsProcessing">
				<i class="fas fa-brain me-1"></i>
				@(string.IsNullOrEmpty(SelectedModel) ? "选择模型" : SelectedModel)
			</button>
			<ul class="dropdown-menu" aria-labelledby="modelDropdown" style="max-height: 300px; overflow-y: auto;">
				@if (IsLoadingModels)
				{
					<li><span class="dropdown-item-text"><i class="fas fa-spinner fa-spin"></i> 加载中...</span></li>
				}
				else if (AvailableModels?.Count > 0)
				{
					@foreach (var model in AvailableModels)
					{
						<li><a class="dropdown-item @(model.Id == SelectedModel ? "active" : "")" 
							   href="#" @onclick="() => OnModelSelected(model.Id)" @onclick:preventDefault="true">
							@model.Id
							@if (!string.IsNullOrEmpty(model.OwnedBy))
							{
								<small class="text-muted d-block">@model.OwnedBy</small>
							}
						</a></li>
					}
				}
				else
				{
					<li><span class="dropdown-item-text text-muted">暂无可用模型</span></li>
					<li><hr class="dropdown-divider"></li>
					<li><a class="dropdown-item" href="#" @onclick="LoadModelsAsync" @onclick:preventDefault="true">
						<i class="fas fa-refresh me-1"></i> 刷新列表
					</a></li>
				}
			</ul>
		</div>


		<button class="btn btn-primary" @onclick="OnExecuteTask"
				disabled="@(IsProcessing || string.IsNullOrWhiteSpace(CurrentMessage))">
			@if (IsProcessing)
			{
				<i class="fas fa-spinner fa-spin"></i>
			}
			else
			{
				<i class="fas fa-paper-plane"></i>
			}
			执行任务
		</button>
	</div>
	@if (SelectedFiles?.Count > 0)
	{
		<div class="mt-2">
			<span>已选择附件：</span>
			@foreach (var file in SelectedFiles)
			{
				<span class="badge bg-secondary me-1">@file.Name</span>
			}
		</div>
	}
</div>

@code {
	/// <summary>
	/// 当前输入的消息内容
	/// </summary>
	[Parameter] public string CurrentMessage { get; set; } = string.Empty;

	/// <summary>
	/// 当前消息内容变化时的回调事件
	/// </summary>
	[Parameter] public EventCallback<string> CurrentMessageChanged { get; set; }

	/// <summary>
	/// 是否正在处理任务的状态标识
	/// </summary>
	[Parameter] public bool IsProcessing { get; set; }

	/// <summary>
	/// 文件预览是否可见的状态标识
	/// </summary>
	[Parameter] public bool IsFilePreviewVisible { get; set; }

	/// <summary>
	/// 已选择的文件列表
	/// </summary>
	[Parameter] public List<IBrowserFile>? SelectedFiles { get; set; }

	/// <summary>
	/// 执行任务时的回调事件
	/// </summary>
	[Parameter] public EventCallback OnExecuteTask { get; set; }

	/// <summary>
	/// 打开文件预览时的回调事件
	/// </summary>
	[Parameter] public EventCallback OnOpenFilePreview { get; set; }

	/// <summary>
	/// 文件选择时的回调事件
	/// </summary>
	[Parameter] public EventCallback<InputFileChangeEventArgs> OnFileSelected { get; set; }

	/// <summary>
	/// 按键事件的回调
	/// </summary>
	[Parameter] public EventCallback<KeyboardEventArgs> OnKeyPress { get; set; }

	/// <summary>
	/// 文本输入框的元素引用
	/// </summary>
	private ElementReference textareaRef;

	/// <summary>
	/// 文件输入控件的引用
	/// </summary>
	private InputFile? fileInputRef;

	/// <summary>
	/// 当前选择的模型
	/// </summary>
	[Parameter] public string SelectedModel { get; set; } = string.Empty;

	/// <summary>
	/// 模型选择变化时的回调事件
	/// </summary>
	[Parameter] public EventCallback<string> SelectedModelChanged { get; set; }

	/// <summary>
	/// 可用的模型列表
	/// </summary>
	private List<ModelInfo>? AvailableModels { get; set; }

	/// <summary>
	/// 是否正在加载模型列表
	/// </summary>
	private bool IsLoadingModels { get; set; } = false;

	/// <summary>
	/// 处理当前消息变化后的回调
	/// </summary>
	/// <returns>异步任务</returns>
	private async Task OnCurrentMessageChanged()
	{
		await CurrentMessageChanged.InvokeAsync(CurrentMessage);
	}

	/// <summary>
	/// 处理键盘按键事件
	/// </summary>
	/// <param name="e">键盘事件参数</param>
	/// <returns>异步任务</returns>
	private async Task HandleKeyPress(KeyboardEventArgs e)
	{
		// Shift+Enter 换行，Enter 发送
		if (e.Key == "Enter" && e.ShiftKey)
		{
			await Task.Delay(10); // 等待内容更新
			await JSRuntime.InvokeVoidAsync("autoResizeTextarea", textareaRef);
		}
		else if (e.Key == "Enter" && !e.ShiftKey && !IsProcessing)
		{
			await OnExecuteTask.InvokeAsync();
		}

		// 调用父组件的按键处理
		// if (OnKeyPress.HasDelegate)
		// {
		//     await OnKeyPress.InvokeAsync(e);
		// }
	}

	/// <summary>
	/// 组件初始化时加载模型列表
	/// </summary>
	protected override async Task OnInitializedAsync()
	{
		await LoadModelsAsync();
	}

	/// <summary>
	/// 从LLM API加载可用模型列表
	/// </summary>
	private async Task LoadModelsAsync()
	{
		try
		{
			IsLoadingModels = true;
			StateHasChanged();

			var appSettings = ConfigurationService.GetAppSettings();
			var llmConfig = appSettings.LLMConfig;

			// 设置请求头
			HttpClient.DefaultRequestHeaders.Clear();
			HttpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {llmConfig.ApiKey}");

			// 调用/v1/models接口
			var response = await HttpClient.GetAsync($"{llmConfig.BaseUrl.TrimEnd('/')}/models");

			if (response.IsSuccessStatusCode)
			{
				var responseContent = await response.Content.ReadAsStringAsync();
				var modelsResponse = JsonSerializer.Deserialize<ModelsResponse>(responseContent, new JsonSerializerOptions
				{
					PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
					PropertyNameCaseInsensitive = true
				});

				AvailableModels = modelsResponse?.Data ?? new List<ModelInfo>();

				// 如果当前没有选择模型，且配置中有默认模型，则设置为默认模型
				if (string.IsNullOrEmpty(SelectedModel) && !string.IsNullOrEmpty(llmConfig.Model))
				{
					var defaultModel = AvailableModels.FirstOrDefault(m => m.Id == llmConfig.Model);
					if (defaultModel != null)
					{
						SelectedModel = defaultModel.Id;
						await SelectedModelChanged.InvokeAsync(SelectedModel);
					}
				}
			}
			else
			{
				// API调用失败时，使用配置中的默认模型
				AvailableModels = new List<ModelInfo>
				{
					new ModelInfo { Id = llmConfig.Model, Object = "model", OwnedBy = "local" }
				};
				if (string.IsNullOrEmpty(SelectedModel))
				{
					SelectedModel = llmConfig.Model;
					await SelectedModelChanged.InvokeAsync(SelectedModel);
				}
			}
		}
		catch (Exception)
		{
			// 异常时使用配置中的默认模型
			var appSettings = ConfigurationService.GetAppSettings();
			var llmConfig = appSettings.LLMConfig;
			AvailableModels = new List<ModelInfo>
			{
				new ModelInfo { Id = llmConfig.Model, Object = "model", OwnedBy = "local" }
			};
			if (string.IsNullOrEmpty(SelectedModel))
			{
				SelectedModel = llmConfig.Model;
				await SelectedModelChanged.InvokeAsync(SelectedModel);
			}
		}
		finally
		{
			IsLoadingModels = false;
			StateHasChanged();
		}
	}

	/// <summary>
	/// 处理模型选择事件
	/// </summary>
	/// <param name="modelId">选择的模型ID</param>
	private async Task OnModelSelected(string modelId)
	{
		SelectedModel = modelId;
		await SelectedModelChanged.InvokeAsync(SelectedModel);
		StateHasChanged();
	}
}